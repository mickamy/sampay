// Code generated by ormgen; DO NOT EDIT.
package query

import (
	"context"
	"database/sql"
	"time"

	"github.com/mickamy/ormgen/orm"
	"github.com/mickamy/ormgen/scope"
	"github.com/mickamy/sampay/internal/domain/event/model"
)

// Events returns a new Query for the events table.
func Events(db orm.Querier) *orm.Query[model.Event] {
	q := orm.NewQuery[model.Event](
		db, orm.ResolveTableName[model.Event]("events"), eventsColumns, "id",
		scanEvent, eventColumnValuePairs, nil,
	)
	q.RegisterJoin("Tiers", orm.JoinConfig{
		TargetTable: orm.ResolveTableName[model.EventTier]("event_tiers"), TargetColumn: "event_id",
		SourceTable: orm.ResolveTableName[model.Event]("events"), SourceColumn: "id",
	})
	q.RegisterPreloader("Tiers", preloadEventTiers)
	q.RegisterJoin("Participants", orm.JoinConfig{
		TargetTable: orm.ResolveTableName[model.EventParticipant]("event_participants"), TargetColumn: "event_id",
		SourceTable: orm.ResolveTableName[model.Event]("events"), SourceColumn: "id",
	})
	q.RegisterPreloader("Participants", preloadEventParticipants)
	q.RegisterTimestamps(
		[]string{"created_at"},
		setEventCreatedAt,
		[]string{"updated_at"},
		setEventUpdatedAt,
	)
	return q
}

var eventsColumns = []string{"id", "user_id", "title", "description", "total_amount", "remainder", "tier_count", "held_at", "created_at", "updated_at"}

func scanEvent(rows *sql.Rows) (model.Event, error) {
	cols, _ := rows.Columns()
	var v model.Event
	dest := make([]any, len(cols))
	for i, col := range cols {
		switch col {
		case "id":
			dest[i] = &v.ID
		case "user_id":
			dest[i] = &v.UserID
		case "title":
			dest[i] = &v.Title
		case "description":
			dest[i] = &v.Description
		case "total_amount":
			dest[i] = &v.TotalAmount
		case "remainder":
			dest[i] = &v.Remainder
		case "tier_count":
			dest[i] = &v.TierCount
		case "held_at":
			dest[i] = &v.HeldAt
		case "created_at":
			dest[i] = &v.CreatedAt
		case "updated_at":
			dest[i] = &v.UpdatedAt
		default:
			dest[i] = new(any)
		}
	}
	err := rows.Scan(dest...)
	return v, err
}

func eventColumnValuePairs(v *model.Event, includesPK bool) ([]string, []any) {
	if includesPK {
		return []string{"id", "user_id", "title", "description", "total_amount", "remainder", "tier_count", "held_at", "created_at", "updated_at"},
			[]any{v.ID, v.UserID, v.Title, v.Description, v.TotalAmount, v.Remainder, v.TierCount, v.HeldAt, v.CreatedAt, v.UpdatedAt}
	}
	return []string{"user_id", "title", "description", "total_amount", "remainder", "tier_count", "held_at", "created_at", "updated_at"},
		[]any{v.UserID, v.Title, v.Description, v.TotalAmount, v.Remainder, v.TierCount, v.HeldAt, v.CreatedAt, v.UpdatedAt}
}

func setEventCreatedAt(v *model.Event, now time.Time) {
	if v.CreatedAt.IsZero() {
		v.CreatedAt = now
	}
}
func setEventUpdatedAt(v *model.Event, now time.Time) {
	v.UpdatedAt = now
}
func preloadEventTiers(ctx context.Context, db orm.Querier, results []model.Event) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]string, len(results))
	for i := range results {
		ids[i] = results[i].ID
	}
	related, err := EventTiers(db).Scopes(scope.In("event_id", ids)).All(ctx)
	if err != nil {
		return err
	}
	byFK := make(map[string][]model.EventTier)
	for _, r := range related {
		byFK[r.EventID] = append(byFK[r.EventID], r)
	}
	for i := range results {
		results[i].Tiers = byFK[results[i].ID]
	}
	return nil
}
func preloadEventParticipants(ctx context.Context, db orm.Querier, results []model.Event) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]string, len(results))
	for i := range results {
		ids[i] = results[i].ID
	}
	related, err := EventParticipants(db).Scopes(scope.In("event_id", ids)).All(ctx)
	if err != nil {
		return err
	}
	byFK := make(map[string][]model.EventParticipant)
	for _, r := range related {
		byFK[r.EventID] = append(byFK[r.EventID], r)
	}
	for i := range results {
		results[i].Participants = byFK[results[i].ID]
	}
	return nil
}
