#!/bin/bash
set -euo pipefail

# Update system
dnf update -y

# Install Docker
dnf install -y docker
systemctl enable docker
systemctl start docker

# Install Docker Compose plugin, EC2 Instance Connect (for emergency access), and jq
dnf install -y docker-compose-plugin ec2-instance-connect jq

# Enable swap (2 GB)
dd if=/dev/zero of=/swapfile bs=1M count=2048
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile
echo '/swapfile swap swap defaults 0 0' >> /etc/fstab

# SSH hardening
sed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
sed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config
sed -i 's/^#*X11Forwarding.*/X11Forwarding no/' /etc/ssh/sshd_config
systemctl restart sshd

# Enable automatic security updates
dnf install -y dnf-automatic
sed -i 's/^apply_updates.*/apply_updates = yes/' /etc/dnf/automatic.conf
sed -i 's/^upgrade_type.*/upgrade_type = security/' /etc/dnf/automatic.conf
systemctl enable --now dnf-automatic-install.timer

# Create deploy user
useradd -m -s /bin/bash deploy
usermod -aG docker deploy
mkdir -p /home/deploy/.ssh
chmod 700 /home/deploy/.ssh
cp /home/ec2-user/.ssh/authorized_keys /home/deploy/.ssh/authorized_keys 2>/dev/null || true
chown -R deploy:deploy /home/deploy/.ssh

# Create app directory
mkdir -p /app
chown deploy:deploy /app

# Generate Caddyfile
cat > /app/Caddyfile << 'CADDYEOF'
${app_domain} {
    reverse_proxy web:3000
}

${api_domain} {
    reverse_proxy api:8080
}
CADDYEOF
chown deploy:deploy /app/Caddyfile

# Generate systemd service
cat > /etc/systemd/system/sampay.service << 'SERVICEEOF'
[Unit]
Description=Sampay Docker Compose
Requires=docker.service
After=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
User=deploy
Group=deploy
WorkingDirectory=/app
ExecStartPre=/app/scripts/ecr-login.sh
ExecStartPre=/app/scripts/pull-secrets.sh
EnvironmentFile=/app/.env.compose
ExecStart=/usr/bin/docker compose -f compose.prod.yaml up -d --remove-orphans
ExecStartPost=/app/scripts/db-init.sh
ExecStop=/usr/bin/docker compose -f compose.prod.yaml down
TimeoutStartSec=120

[Install]
WantedBy=multi-user.target
SERVICEEOF

systemctl daemon-reload
# Service is not enabled by default; enable after initial deployment populates .env.compose

# Install pull-secrets script
mkdir -p /app/scripts
cat > /app/scripts/pull-secrets.sh << 'PULLEOF'
${pull_secrets_sh}
PULLEOF
chmod 700 /app/scripts/pull-secrets.sh

# Install ECR login script
cat > /app/scripts/ecr-login.sh << 'ECREOF'
#!/bin/bash
set -euo pipefail
IMDS_TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 60")
REGION=$(curl -s -H "X-aws-ec2-metadata-token: $IMDS_TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
ACCOUNT=$(curl -s -H "X-aws-ec2-metadata-token: $IMDS_TOKEN" http://169.254.169.254/latest/meta-data/identity-credentials/ec2/info | jq -r .AccountId)
aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "$ACCOUNT.dkr.ecr.$REGION.amazonaws.com"
ECREOF
chmod 700 /app/scripts/ecr-login.sh

# Install DB init script
cat > /app/scripts/db-init.sh << 'DBINITEOF'
${db_init_sh}
DBINITEOF
chmod 700 /app/scripts/db-init.sh

# Create placeholder env files with restrictive permissions
# .env.compose: orchestration vars (ECR URLs, IMAGE_TAG, SM_PREFIX)
# .env.postgres: generated by pull-secrets.sh from SM
touch /app/.env.compose
touch /app/.env.postgres
chown -R deploy:deploy /app/scripts /app/.env.*
chmod 600 /app/.env.*
